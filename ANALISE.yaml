Opção 2 — Quando o HITSS só fornece XLSX (sem CSV/JSON possível)
Resumo rápido: implementar um Wrapper Wasm (Wasm FDW) dentro do Supabase (Wrappers) que faça o download do XLSX, parseie o arquivo (.xlsx é um ZIP de XML) e exponha os dados como uma tabela estrangeira (foreign table) ou função SQL. A solução roda inteiramente dentro do ecossistema Supabase sem serviços externos persistentes.

Visão geral da arquitetura
Um módulo Wasm (escrito em Rust) é empacotado como um Wrapper (Wasm FDW) que:
Autentica contra o endpoint HITSS (uso das credenciais guardadas — ver seção Segurança).
Baixa o arquivo XLSX (stream ou em memória).
Descompacta o ZIP e parseia os XMLs das sheets (usando quick-xml / um parser XML leve).
Converte linhas em registros e retorna como rows para o Postgres via FDW.
No Postgres (Supabase) você registra o wrapper, cria um foreign server e uma foreign table ou view para consultar os dados diretamente com SQL/INSERT.
Pré-requisitos
Acesso para criar Wrappers/Wasm FDW no projeto Supabase (roles/admin).
Credenciais do HITSS armazenadas com segurança (Supabase Vault / Secrets) e acessíveis pelo Wrapper através de opções do foreign server ou variáveis de ambiente permitidas.
Ferramentas de build para Rust -> Wasm/WASI (cargo + target wasm32-wasi / wasm32-unknown-unknown conforme o ambiente do wrapper no Supabase).
Testes locais (rodar o módulo Wasm numa sandbox WASI para validar).
Fluxo detalhado
Criar o wrapper Wasm (Rust):
Biblioteca que expõe uma função entrypoint para o FDW (interface esperada pelo Supabase Wrappers).
Recebe parâmetros: URL do XLSX (+ headers / cookies / auth token), nome da sheet(s) a extrair, mapeamento de colunas (opcional).
Faz request HTTP ao HITSS (com autenticação).
Lê resposta em chunks (se possível), armazena em buffer.
Usa um parser ZIP (zip-rs ou miniz_oxide — garantir compatibilidade com WASI) para extrair os XMLs: /xl/sharedStrings.xml, /xl/worksheets/sheet1.xml, /xl/styles.xml (se precisar).
Parseia XML com quick-xml (funciona em WASI) para obter células e linhas convertidas para strings/numéricos.
Emite rows no formato esperado pelo FDW para PostgreSQL.
Empacotar e publicar o Wasm no Supabase Wrappers:
Build para o target WASI usado pela plataforma.
Subir o binário Wasm via interface de Wrappers do Supabase (ou supabase CLI se disponível).
Registrar o wrapper.
Criar foreign server / foreign table:
No banco:
CREATE EXTENSION wrappers_fdw; (ou equivalente se a extensão se chama diferente)
CREATE SERVER hitss_xlsx_server FOREIGN DATA WRAPPER wrappers_fdw OPTIONS (wrapper => 'nome_do_wrapper', url => 'https://...', auth_header => '<token/secret-key>') — os detalhes dependem da integração.
CREATE FOREIGN TABLE dre_hitss_wrapped (colunas...) SERVER hitss_xlsx_server OPTIONS (sheet => 'Sheet1', range => 'A1:Z1000', etc);
Alternativa: criar uma função SQL que chama o wrapper e retorna SETOF record, e fazer INSERT ... SELECT para popular dre_hitss.
Agendamento:
Usar Cron Jobs do Supabase para agendar uma query que executa a inserção/refresh:
Ex.: CALL refresh_dre_hitss(); ou INSERT INTO dre_hitss SELECT * FROM dre_hitss_wrapped;
Se preferir incremental, o wrapper pode suportar parâmetros de data / filtro via options do foreign server ou colunas de função.
Exemplo de SQL (modelo)
(ajuste nomes conforme seu ambiente/wrapper)

-- Registrar foreign server (exemplo)
CREATE SERVER hitss_wasm_server
FOREIGN DATA WRAPPER wrappers_fdw
OPTIONS (wrapper = 'hitss_xlsx_wrapper');

-- Mapear credenciais / URL como opções do server ou nas options da foreign table
CREATE FOREIGN TABLE dre_hitss_wrapped (
  id text,
  cliente text,
  servico text,
  valor numeric,
  data_emissao date
)
SERVER hitss_wasm_server
OPTIONS (
  url 'https://hitss.example.com/export.xlsx?token=***',
  sheet 'Sheet1'
);

-- Atualização agendada (exemplo)
INSERT INTO dre_hitss (id, cliente, servico, valor, data_emissao)
SELECT id, cliente, servico, valor, data_emissao
FROM dre_hitss_wrapped;
Esqueleto de código Rust (Wasm) — alto nível
rust
Copy
// PSEUDO-CÓDIGO: ajuste para a API do wrapper e WASI target da Supabase
use quick_xml::Reader;
use zip::ZipArchive;
use reqwest; // garantir compatibilidade WASI ou usar uma lib HTTP suportada
use std::io::Cursor;

pub fn handle_request(opts: WrapperOptions) -> Result<Rows, Error> {
    // 1) Autentica / faz GET (usar timeout e retries)
    let resp_bytes = http_get_bytes(&opts.url, &opts.headers)?;

    // 2) Abrir ZIP
    let reader = Cursor::new(resp_bytes);
    let mut zip = ZipArchive::new(reader)?;

    // 3) Ler sharedStrings se existir
    let shared = extract_shared_strings(&mut zip)?;

    // 4) Ler sheet XML (sheet1.xml)
    let sheet_xml = read_zip_file(&mut zip, "xl/worksheets/sheet1.xml")?;
    let rows = parse_sheet_xml(&sheet_xml, &shared)?;

    // 5) Mapear para o formato que o FDW espera e retornar
    Ok(rows)
}

// Funções auxiliares: http_get_bytes, extract_shared_strings, parse_sheet_xml (quick-xml)
Observações importantes sobre libs:

Muitos crates de alto nível para XLSX (ex.: calamine) usam std::fs e não funcionam facilmente em WASI/Wasm; por isso a recomendação é fazer parsing manual do ZIP+XML com zip/quick-xml que normalmente são mais portáveis.
Teste localmente em WASI (wasmtime) antes de subir para o Supabase.
Segurança e credenciais
Não colocar tokens sensíveis diretamente no código.
Armazenar credenciais no Supabase Vault/Secrets.
Passar o token ao wrapper como opção do foreign server (server options) ou por variáveis de ambiente seguras fornecidas pela plataforma.
Se o wrapper precisa de cookies de sessão, implemente um fluxo de autenticação programático (POST/LOGIN) e refresque o cookie dentro do wrapper.
Limitações e riscos
Complexidade: construir e testar um parser XLSX em Wasm exige trabalho (ZIP + XML). Nem todas as bibliotecas Rust para XLSX são WASI-compatíveis.
Tempo de execução: a execução do wrapper ocorre sob limites impostos pela plataforma (mas geralmente wrappers/Wasm FDWs são projetados para operações de IO relativamente longas — ver limites do seu projeto).
Consumo de memória: arquivos XLSX muito grandes podem exigir streaming; implemente parser em streaming para evitar carregar tudo em memória.
Debugging: mais difícil em produção; prepare logs detalhados e um modo de teste local.
Plano B (se o Wasm FDW se mostrar inviável)
Criar um micro-serviço externo (serverless/worker) que faz o download e escreve CSV/JSON no Supabase Storage; então uma Edge Function/cron no Supabase consome esse CSV/JSON e popula a tabela. (Isso exige recursos externos — você disse querer só Supabase; usar isto apenas se realmente impossível fazer em Wasm.)
Checklist prático para você executar
Confirmar acesso para criar Wrappers no Supabase.
Escolher/validar crates Rust compatíveis com WASI (zip, quick-xml).
Escrever e testar localmente o parser XLSX (WASI).
Empacotar Wasm e subir como Wrapper no Supabase.
Criar foreign server / foreign table e testar SELECT.
Criar rotina de inserção/refresh e agendar com Cron Jobs.
Monitorar logs e ajustar timeouts/retries.


Segue link

https://hitsscontrol.globalhitss.com.br/api/api/export/xls?clienteFiltro=&servicoFiltro=-1&tipoFiltro=-1&projetoFiltro=&projetoAtivoFiltro=true&projetoParalisadoFiltro=true&projetoEncerradoFiltro=true&projetoCanceladoFiltro=true&responsavelareaFiltro=&idResponsavelareaFiltro=&responsavelprojetoFiltro=FABRICIO%20CARDOSO%20DE%20LIMA&idresponsavelprojetoFiltro=78&filtroDeFiltro=09-2016&filtroAteFiltro=08-2025&visaoFiltro=PROJ&usuarioFiltro=fabricio.lima&idusuarioFiltro=78&perfilFiltro=RESPONSAVEL_DELIVERY%7CRESPONSAVEL_LANCAMENTO%7CVISITANTE&telaFiltro=painel_projetos
