import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Carregar vari√°veis de ambiente
dotenv.config();

console.log('üöÄ Iniciando Teste End-to-End do Fluxo DRE');
console.log('=' .repeat(50));

// Configura√ß√£o do Supabase
const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY;

console.log('üìã Configura√ß√µes:');
console.log(`URL Supabase: ${supabaseUrl}`);
console.log(`Chave Anon: ${supabaseKey ? supabaseKey.substring(0, 20) + '...' : 'N√ÉO CONFIGURADA'}`);
console.log('');

if (!supabaseUrl || !supabaseKey) {
  console.error('‚ùå Erro: Vari√°veis de ambiente do Supabase n√£o configuradas');
  console.error('Verifique VITE_SUPABASE_URL e VITE_SUPABASE_ANON_KEY no arquivo .env');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

// Classe para relat√≥rio de testes
class SimpleTestReporter {
  constructor() {
    this.results = [];
    this.startTime = new Date();
  }

  addResult(step, status, message, details = {}) {
    const timestamp = new Date().toISOString();
    this.results.push({
      step,
      status,
      message,
      timestamp,
      details
    });
    
    const statusIcon = status === 'SUCCESS' ? '‚úÖ' : status === 'ERROR' ? '‚ùå' : '‚ö†Ô∏è';
    console.log(`${statusIcon} [${step}] ${message}`);
    
    if (details && Object.keys(details).length > 0) {
      console.log('   üìä Detalhes:', JSON.stringify(details, null, 2));
    }
    console.log('');
  }

  generateReport() {
    const endTime = new Date();
    const duration = endTime - this.startTime;
    
    const report = {
      testSuite: 'Teste End-to-End Simplificado do Fluxo DRE',
      startTime: this.startTime.toISOString(),
      endTime: endTime.toISOString(),
      duration: `${duration}ms`,
      totalSteps: this.results.length,
      successCount: this.results.filter(r => r.status === 'SUCCESS').length,
      errorCount: this.results.filter(r => r.status === 'ERROR').length,
      warningCount: this.results.filter(r => r.status === 'WARNING').length,
      results: this.results
    };

    // Salvar relat√≥rio em arquivo
    const reportFileName = `dre-simple-test-report-${Date.now()}.json`;
    const reportPath = path.join(__dirname, reportFileName);
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    console.log('üìä RELAT√ìRIO FINAL DO TESTE');
    console.log('=' .repeat(40));
    console.log(`‚è±Ô∏è  Dura√ß√£o total: ${duration}ms`);
    console.log(`üìà Total de etapas: ${report.totalSteps}`);
    console.log(`‚úÖ Sucessos: ${report.successCount}`);
    console.log(`‚ùå Erros: ${report.errorCount}`);
    console.log(`‚ö†Ô∏è  Avisos: ${report.warningCount}`);
    console.log(`üíæ Relat√≥rio salvo em: ${reportFileName}`);
    
    return report;
  }
}

// Classe principal de teste
class SimpleDREFlowTester {
  constructor() {
    this.reporter = new SimpleTestReporter();
  }

  async runAllTests() {
    try {
      await this.testSupabaseConnection();
      await this.testCronJobStatus();
      await this.testBucketAccess();
      await this.testEdgeFunctions();
      await this.testDatabaseTables();
      await this.testVaultCredentials();
      await this.testEmailConfiguration();
      
    } catch (error) {
      this.reporter.addResult(
        'TESTE_GERAL',
        'ERROR',
        `Erro cr√≠tico durante execu√ß√£o: ${error.message}`,
        { error: error.stack }
      );
    }
    
    return this.reporter.generateReport();
  }

  // Teste 1: Conectividade com Supabase
  async testSupabaseConnection() {
    try {
      this.reporter.addResult('CONECTIVIDADE', 'INFO', 'Testando conex√£o com Supabase...');
      
      // Teste b√°sico de conectividade
      const { data, error } = await supabase
        .from('vault')
        .select('count')
        .limit(1);
      
      if (error) {
        this.reporter.addResult(
          'CONECTIVIDADE',
          'ERROR',
          `Erro na conex√£o: ${error.message}`,
          { error }
        );
        return;
      }
      
      this.reporter.addResult(
        'CONECTIVIDADE',
        'SUCCESS',
        'Conex√£o com Supabase estabelecida com sucesso'
      );
      
    } catch (error) {
      this.reporter.addResult(
        'CONECTIVIDADE',
        'ERROR',
        `Erro na conectividade: ${error.message}`,
        { error: error.stack }
      );
    }
  }

  // Teste 2: Status do Cron Job
  async testCronJobStatus() {
    try {
      this.reporter.addResult('CRON_JOB', 'INFO', 'Verificando status do cron job...');
      
      // Verificar se existe a tabela pg_cron_jobs
      const { data: cronJobs, error } = await supabase
        .rpc('get_cron_jobs_status');
      
      if (error) {
        this.reporter.addResult(
          'CRON_JOB',
          'WARNING',
          `N√£o foi poss√≠vel verificar cron jobs: ${error.message}`,
          { error }
        );
        return;
      }
      
      this.reporter.addResult(
        'CRON_JOB',
        'SUCCESS',
        `Cron jobs verificados`,
        { cronJobsCount: cronJobs?.length || 0 }
      );
      
    } catch (error) {
      this.reporter.addResult(
        'CRON_JOB',
        'WARNING',
        `Erro na verifica√ß√£o do cron job: ${error.message}`,
        { error: error.stack }
      );
    }
  }

  // Teste 3: Acesso ao Bucket
  async testBucketAccess() {
    try {
      this.reporter.addResult('BUCKET', 'INFO', 'Testando acesso ao bucket dre-files...');
      
      // Listar buckets dispon√≠veis
      const { data: buckets, error: bucketsError } = await supabase.storage.listBuckets();
      
      if (bucketsError) {
        this.reporter.addResult(
          'BUCKET',
          'ERROR',
          `Erro ao listar buckets: ${bucketsError.message}`,
          { error: bucketsError }
        );
        return;
      }
      
      const bucketNames = buckets.map(b => b.name);
      const dreFilesExists = bucketNames.includes('dre-files');
      
      if (dreFilesExists) {
        this.reporter.addResult(
          'BUCKET',
          'SUCCESS',
          'Bucket dre-files encontrado',
          { availableBuckets: bucketNames }
        );
      } else {
        this.reporter.addResult(
          'BUCKET',
          'WARNING',
          'Bucket dre-files n√£o encontrado',
          { availableBuckets: bucketNames }
        );
      }
      
    } catch (error) {
      this.reporter.addResult(
        'BUCKET',
        'ERROR',
        `Erro no teste de bucket: ${error.message}`,
        { error: error.stack }
      );
    }
  }

  // Teste 4: Edge Functions
  async testEdgeFunctions() {
    try {
      this.reporter.addResult('EDGE_FUNCTIONS', 'INFO', 'Testando Edge Functions...');
      
      const functions = [
        'hitss-automation',
        'process-dre-upload',
        'send-dre-notification'
      ];
      
      for (const functionName of functions) {
        try {
          const { data, error } = await supabase.functions
            .invoke(functionName, {
              body: { test: true, ping: true }
            });
          
          if (error) {
            this.reporter.addResult(
              'EDGE_FUNCTIONS',
              'WARNING',
              `Edge Function ${functionName}: ${error.message}`,
              { functionName, error }
            );
          } else {
            this.reporter.addResult(
              'EDGE_FUNCTIONS',
              'SUCCESS',
              `Edge Function ${functionName} respondeu`,
              { functionName, response: data }
            );
          }
        } catch (err) {
          this.reporter.addResult(
            'EDGE_FUNCTIONS',
            'WARNING',
            `Edge Function ${functionName} n√£o acess√≠vel: ${err.message}`,
            { functionName, error: err.message }
          );
        }
      }
      
    } catch (error) {
      this.reporter.addResult(
        'EDGE_FUNCTIONS',
        'ERROR',
        `Erro no teste de Edge Functions: ${error.message}`,
        { error: error.stack }
      );
    }
  }

  // Teste 5: Tabelas do Banco de Dados
  async testDatabaseTables() {
    try {
      this.reporter.addResult('DATABASE', 'INFO', 'Verificando tabelas do banco de dados...');
      
      const tables = [
        'dre_reports',
        'dre_items', 
        'dre_categories',
        'automation_executions',
        'system_logs',
        'vault'
      ];
      
      for (const table of tables) {
        try {
          const { data, error, count } = await supabase
            .from(table)
            .select('*', { count: 'exact', head: true });
          
          if (error) {
            this.reporter.addResult(
              'DATABASE',
              'WARNING',
              `Tabela ${table}: ${error.message}`,
              { table, error }
            );
          } else {
            this.reporter.addResult(
              'DATABASE',
              'SUCCESS',
              `Tabela ${table} acess√≠vel`,
              { table, recordCount: count }
            );
          }
        } catch (err) {
          this.reporter.addResult(
            'DATABASE',
            'WARNING',
            `Tabela ${table} n√£o acess√≠vel: ${err.message}`,
            { table, error: err.message }
          );
        }
      }
      
    } catch (error) {
      this.reporter.addResult(
        'DATABASE',
        'ERROR',
        `Erro no teste de tabelas: ${error.message}`,
        { error: error.stack }
      );
    }
  }

  // Teste 6: Credenciais no Vault
  async testVaultCredentials() {
    try {
      this.reporter.addResult('VAULT', 'INFO', 'Verificando credenciais no vault...');
      
      const requiredKeys = [
        'HITSS_USERNAME',
        'HITSS_PASSWORD', 
        'HITSS_BASE_URL',
        'RESEND_API_KEY'
      ];
      
      const { data: vaultData, error } = await supabase
        .from('vault')
        .select('key, value')
        .in('key', requiredKeys);
      
      if (error) {
        this.reporter.addResult(
          'VAULT',
          'ERROR',
          `Erro ao acessar vault: ${error.message}`,
          { error }
        );
        return;
      }
      
      const foundKeys = vaultData?.map(item => item.key) || [];
      const missingKeys = requiredKeys.filter(key => !foundKeys.includes(key));
      const configuredKeys = vaultData?.filter(item => item.value && item.value.trim() !== '') || [];
      
      this.reporter.addResult(
        'VAULT',
        missingKeys.length === 0 ? 'SUCCESS' : 'WARNING',
        `Credenciais verificadas`,
        {
          totalRequired: requiredKeys.length,
          found: foundKeys.length,
          configured: configuredKeys.length,
          missingKeys
        }
      );
      
    } catch (error) {
      this.reporter.addResult(
        'VAULT',
        'ERROR',
        `Erro na verifica√ß√£o do vault: ${error.message}`,
        { error: error.stack }
      );
    }
  }

  // Teste 7: Configura√ß√£o de Email
  async testEmailConfiguration() {
    try {
      this.reporter.addResult('EMAIL', 'INFO', 'Verificando configura√ß√£o de email...');
      
      // Verificar se a chave do Resend est√° configurada
      const { data: resendConfig } = await supabase
        .from('vault')
        .select('value')
        .eq('key', 'RESEND_API_KEY')
        .single();
      
      if (!resendConfig || !resendConfig.value) {
        this.reporter.addResult(
          'EMAIL',
          'WARNING',
          'Chave API do Resend n√£o configurada no vault',
          { missingKey: 'RESEND_API_KEY' }
        );
        return;
      }
      
      this.reporter.addResult(
        'EMAIL',
        'SUCCESS',
        'Configura√ß√£o de email encontrada',
        { configured: true }
      );
      
    } catch (error) {
      this.reporter.addResult(
        'EMAIL',
        'ERROR',
        `Erro na verifica√ß√£o de email: ${error.message}`,
        { error: error.stack }
      );
    }
  }
}

// Fun√ß√£o principal
async function main() {
  const tester = new SimpleDREFlowTester();
  const report = await tester.runAllTests();
  
  // Determinar status geral
  const hasErrors = report.errorCount > 0;
  const hasWarnings = report.warningCount > 0;
  
  let overallStatus = 'SUCCESS';
  if (hasErrors) {
    overallStatus = 'ERROR';
  } else if (hasWarnings) {
    overallStatus = 'WARNING';
  }
  
  console.log('üéØ RESULTADO FINAL');
  console.log('=' .repeat(30));
  console.log(`üìä Status Geral: ${overallStatus}`);
  console.log(`üìà Percentual de Sucesso: ${Math.round((report.successCount / report.totalSteps) * 100)}%`);
  
  if (hasErrors) {
    console.log('\n‚ùå Problemas cr√≠ticos encontrados:');
    report.results
      .filter(r => r.status === 'ERROR')
      .forEach(r => console.log(`   üî∏ ${r.step}: ${r.message}`));
  }
  
  if (hasWarnings) {
    console.log('\n‚ö†Ô∏è Avisos que merecem aten√ß√£o:');
    report.results
      .filter(r => r.status === 'WARNING')
      .forEach(r => console.log(`   üî∏ ${r.step}: ${r.message}`));
  }
  
  console.log('\n‚úÖ Teste End-to-End Simplificado conclu√≠do!');
  console.log('üîó Para executar o teste completo, use: node test-end-to-end-dre.js');
  
  return report;
}

// Executar se chamado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}

export { SimpleDREFlowTester, main };